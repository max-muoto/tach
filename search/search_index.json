{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#what-is-tach","title":"What is tach?","text":"<p><code>tach</code> allows you to define boundaries and control dependencies between your Python packages. Packages can also define an explicit public interface through <code>__all__</code> to prevent deep coupling.</p> <p>This enforces a decoupled, modular architecture, which makes maintenance and development easier.</p> <p>If a package tries to import from another package that is not listed as a dependency, <code>tach</code> will throw an exception.</p> <p>When a package is in 'strict mode', if another package tries to import from it without using its public interface, <code>tach</code> will throw an exception.</p> <p><code>tach</code> runs on the CLI, and is ideal for pre-commit hooks and CI checks.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>tach pkg</code> - Interactively define package boundaries in your Python project.</li> <li><code>tach check</code> - Check that boundaries are respected.</li> <li><code>tach sync</code> - Sync constraints with actual dependencies in your Python project.</li> <li><code>tach install</code> - Install <code>tach</code> into your development workflow (e.g. pre-commit)</li> <li><code>tach clean</code> - Delete all existing configuration and start from a clean slate.</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>Aside from running <code>tach pkg</code> and <code>tach sync</code>, you can configure <code>tach</code> by creating or modifying the files described below.</p>"},{"location":"configuration/#tachyml","title":"<code>tach.yml</code>","text":"<p>This is the project-level configuration file which should be in the root of your project.</p> <p><code>constraints</code> defines the expected dependencies between tags in your project, and accepts a list of constraints as shown below</p> <p><code>exclude</code> accepts a list of directory patterns to exclude from checking.</p> <p><code>ignore_type_checking_imports</code> is a boolean which, when enabled, silences <code>tach check</code> failures caused by imports under a <code>TYPE_CHECKING</code> conditional block</p> <pre><code>constraints:\n- tag: scope:filesystem\n  depends_on:\n  - scope:utils\n- tag: scope:parsing\n  depends_on:\n  - scope:core\n  - scope:filesystem\n  - scope:utils\n- tag: scope:root\n  depends_on:\n  - scope:utils\n  - scope:core\n  - scope:filesystem\n  - scope:parsing\nexclude:\n- tests/\n- docs/\n- build/\nexclude_hidden_paths: true\nignore_type_checking_imports: true\n</code></pre>"},{"location":"configuration/#packageyml","title":"<code>package.yml</code>","text":"<p>This is the package-level configuration file which should exist in each package in your project.</p> <p><code>tags</code> accepts a list of string tags which are checked against project-level <code>constraints</code></p> <p><code>strict</code> accepts a boolean which enables 'Strict Mode' for the package.</p> <pre><code>tags: ['scope:utils']\nstrict: true\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#how-does-it-work","title":"How does it work?","text":"<p><code>tach</code> works by analyzing the imports in your packages. When you define constraints in your project-level <code>tach.yml</code>, running <code>tach check</code> will verify that the imports in your packages don't create unwanted dependencies.</p>"},{"location":"faq/#what-is-a-constraint","title":"What is a constraint?","text":"<p>A constraint is a rule written into your <code>tach.yml</code> which specifies how packages can depend on each other, based on their tags. For example, you can write a constraint which prevents a shared <code>utility</code> package from depending on your <code>core</code> application code.</p>"},{"location":"faq/#are-conditional-imports-checked","title":"Are conditional imports checked?","text":"<p>At the moment, <code>tach</code> will check all imports in your source files, including those which are called conditionally. The only exceptions are imports made within <code>TYPE_CHECKING</code> conditional blocks. If you want to disable checks for these imports, you can add <code>ignore_type_checking_imports: true</code> to your <code>tach.yml</code>.</p>"},{"location":"faq/#can-you-catch-dynamic-references","title":"Can you catch dynamic references?","text":"<p>Since <code>tach</code> uses the AST to find imports and public members, dynamic imports (e.g. using a string path) and dynamic names (e.g. using <code>setattr</code>, <code>locals</code>, <code>globals</code>) are generally not supported. If these usages cause <code>tach</code> to report incorrect errors, the ignore directive should be sufficient to reach a passing state.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>PyPi package</p> <p>Install tach into a Python environment with <code>pip</code></p> <pre><code>pip install tach\n</code></pre> <p>Verify your installation is working correctly <pre><code>tach -h\n</code></pre></p>"},{"location":"getting-started/#adding-to-a-project","title":"Adding to a Project","text":"<p>If you are adding <code>tach</code> to an existing project, you have two main options:</p> <ol> <li>Use <code>tach pkg</code>  to interactively set up packages, and <code>tach sync</code> to automatically set up dependency rules.</li> <li>Manually configure your packages and dependency rules</li> </ol>"},{"location":"getting-started/#checking-boundaries","title":"Checking Boundaries","text":"<pre><code># From the root of your Python project\ntach check\n</code></pre> <p>After guarding your project, running <code>tach check</code> from the root will check all imports to verify that packages remain correctly decoupled.</p>"},{"location":"strict-mode/","title":"Strict Mode","text":"<p>A package can enable 'strict mode' by setting <code>strict: true</code> in the <code>package.yml</code> file.</p>"},{"location":"strict-mode/#how-does-it-work","title":"How does it work?","text":"<p>When a package is in strict mode, other packages may only import names declared in <code>__all__</code> in the <code>__init__.py</code> of the package. This creates an explicit public interface for the package which prevents coupling to implementation details, and makes future changes easier.</p>"},{"location":"strict-mode/#example","title":"Example","text":"<p>Given packages called 'core' and 'parsing', we may have <code>package.yml</code> and <code>tach.yml</code> contents like this:</p> <pre><code># core/package.yml\ntags: ['core']\nstrict: true\n</code></pre> <pre><code># parsing/package.yml\ntags: ['parsing']\n</code></pre> <pre><code># tach.yml\nconstraints:\n- tag: parsing\n  depends_on:\n  - core\n</code></pre> <p>Then, in a file within the 'parsing' package, we may have: <pre><code>from core.main import get_data  # This import fails\n\nget_data()\n</code></pre></p> <p>This import would fail <code>tach check</code> with the following error: <pre><code>\u274c parsing: Package 'core' is in strict mode. Only imports from the root of this package are allowed. The import 'core.main.get_data' (in 'parsing') is not included in __all__.\n</code></pre></p> <p>If <code>get_data</code> should actually be part of the public interface of 'core', it needs to be specified in <code>__all__</code> of <code>core/__init__.py</code>:</p> <p><code>core/__init__.py</code> <pre><code>from .main import get_data\n\n__all__ = [\"get_data\"]\n</code></pre></p> <p>which would allow 'parsing' to depend on this interface:</p> <p><pre><code>from core import get_data  # This import is OK\n\nget_data()\n</code></pre> <code>tach check</code> will now pass! <pre><code>\u2705 All package dependencies validated!\n</code></pre></p>"},{"location":"tach-ignore/","title":"<code>tach-ignore</code>","text":"<p>To ignore a particular import which should be allowed unconditionally, use the <code>tach-ignore</code> comment directive. <pre><code># tach-ignore\nfrom core.main import private_function\n</code></pre> The directive can also be specific about the import to ignore, which is particularly useful when importing multiple packages. <pre><code># tach-ignore private_function\nfrom core.main import private_function, public_function\n</code></pre> Note: Names given to <code>tach-ignore</code> should match the alias as it is used in the subsequent import line, not the full module path from the project root.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#tach-check","title":"tach check","text":"<p><code>tach</code> will flag any unwanted imports between packages. We recommend you run <code>tach check</code> like a linter or test runner, e.g. in pre-commit hooks, on-save hooks, and in CI pipelines.</p> <pre><code>usage: tach check [-h] [-e file_or_path,...]\n\nCheck boundaries with tach\n\noptions:\n  -h, --help            show this help message and exit\n  -e file_or_path,..., --exclude file_or_path,...\n                        Comma separated path list to exclude. tests/, ci/, etc.\n</code></pre> <p>An error will indicate:</p> <ul> <li>the file path in which the error was detected</li> <li>the tags associated with that file</li> <li>the tags associated with the attempted import</li> </ul> <p>Example: <pre><code># From the root of your Python project (in this example, `project/`)\n&gt; tach check\n\u274c utils/helpers.py[L10]: Cannot import 'core.PublicAPI'. Tags ['utils'] cannot depend on ['core'].\n</code></pre></p> <p>NOTE: If your terminal supports hyperlinks, you can click on the failing file path to go directly to the error.</p>"},{"location":"usage/#tach-pkg","title":"tach pkg","text":"<p><code>tach</code> comes bundled with a command to set up and define your initial boundaries.</p> <pre><code>usage: tach pkg [-h] [-d [DEPTH]] [-e file_or_path,...]\n\nConfigure package boundaries interactively\n\noptions:\n  -h, --help            show this help message and exit\n  -d [DEPTH], --depth [DEPTH]\n                        The number of child directories to search for packages to auto-select\n  -e file_or_path,..., --exclude file_or_path,...\n                        Comma separated path list to exclude. tests/, ci/, etc.\n</code></pre> <p>Running <code>tach pkg</code> will open an interactive editor in your terminal which allows you to mark your package boundaries.</p> <p>You can navigate with the arrow keys, mark individual packages with <code>Enter</code>, and mark all sibling directories as packages with <code>Ctrl + a</code>.</p> <p>If you have not configured <code>tach</code> in your project before, <code>tach pkg</code> will automatically mark an initial set of packages. The <code>--depth</code> flag controls how many directories <code>tach</code> will traverse when suggesting these initial packages. You can accept these suggestions immediately with <code>Ctrl + s</code>, or you can edit the selections freely before confirming.</p> <p>Any time you make changes with <code>tach pkg</code>, it is recommended to run <code>tach sync</code> to automatically set up dependency rules.</p>"},{"location":"usage/#tach-sync","title":"tach sync","text":"<p><code>tach</code> can automatically sync your project configuration (<code>tach.yml</code>) with your project's actual dependencies.</p> <pre><code>usage: tach sync [-h] [--prune] [-e file_or_path,...]\n\nSync constraints with actual dependencies in your project.\n\noptions:\n  -h, --help            show this help message and exit\n  --prune               Prune all existing constraints and re-sync dependencies.\n  -e file_or_path,..., --exclude file_or_path,...\n                        Comma separated path list to exclude. tests/, ci/, etc.\n</code></pre> <p>When this command runs, <code>tach</code> will analyze the imports in your packages.</p> <p>Any undeclared dependencies or other dependency errors will be automatically resolved by adding the corresponding dependencies to your <code>tach.yml</code> file.</p> <p>If you supply <code>--prune</code>, any dependency constraints in your <code>tach.yml</code> which are not necessary will also be removed.</p>"},{"location":"usage/#tach-clean","title":"tach clean","text":"<p>If you ever want to remove all configuration for <code>tach</code> and start over, you can use <code>tach clean</code>:</p> <pre><code>usage: tach clean [-h] [--force]\n\nDelete existing configuration and start from an empty slate.\n\noptions:\n  -h, --help  show this help message and exit\n  --force     Do not prompt for confirmation.\n</code></pre> <p>This will find the nearest <code>tach</code> project in parent directories, or simply work from the current directory. It will remove <code>tach.yml</code> along with any <code>package.yml</code> files it finds.</p>"},{"location":"usage/#tach-install","title":"tach install","text":"<p><code>tach</code> can be installed into your development workflow automatically as a pre-commit hook.</p>"},{"location":"usage/#with-pre-commit-framework","title":"With pre-commit framework","text":"<p>If you use the pre-commit framework, you can add the following to your <code>.pre-commit-hooks.yaml</code>:</p> <pre><code>repos:\n-   repo: https://github.com/gauge-sh/tach\n    rev: v0.2.2  # change this to the latest tag!\n    hooks:\n    -   id: tach\n        # args: [\"--root=backend_root\"]\n</code></pre> <p>Note that you should specify the version you are using in the <code>rev</code> key.</p> <p>Using <code>args</code>, you can specify the root of your Python project, where <code>tach check</code> should run. This path should be relative to your git root.</p>"},{"location":"usage/#standard-install","title":"Standard install","text":"<p>If you don't already have pre-commit hooks set up, you can run:</p> <pre><code>tach install pre-commit\n</code></pre> <p>The command above will install <code>tach check</code> as a pre-commit hook, directly into <code>.git/hooks/pre-commit</code>.</p> <p>If that file already exists, you will need to manually add <code>tach check</code> to your existing <code>.git/hooks/pre-commit</code> file.</p>"},{"location":"why-tach/","title":"Why <code>tach</code>?","text":""},{"location":"why-tach/#the-problem","title":"The Problem","text":"<p>By default, Python allows you to import and use anything, anywhere. Over time, this results in modules that were intended to be separate getting tightly coupled together, and domain boundaries breaking down. We experienced this first-hand at a unicorn startup, where the entire engineering team paused development for over a year in an attempt to split up tightly coupled packages into independent micro-services. This ultimately failed, and resulted in the CTO getting fired.</p> <p>This problem occurs because:</p> <ul> <li>It's much easier to add to an existing package rather than create a new one</li> <li>Junior devs have a limited understanding of the existing architecture</li> <li>External pressure leading to shortcuts and overlooking best practices</li> </ul> <p>Attempts we've seen to fix this problem always came up short. A patchwork of solutions would attempt to solve this from different angles, such as developer education, CODEOWNERs, standard guides, refactors, and more. However, none of these addressed the root cause. </p>"},{"location":"why-tach/#the-solution","title":"The Solution","text":"<p>With <code>tach</code>, you can:</p> <ol> <li>Declare your packages (<code>package.yml</code>)</li> <li>Define dependencies between packages (<code>tach.yml</code>)</li> <li>Enforce those dependencies (<code>tach check</code>)</li> </ol> <p>You can also enforce a strict interface for each package. This means that only imports that are directly listed in <code>__init__.py</code> can be imported by other packages.</p> <p><code>tach</code> is:</p> <ul> <li>fully open source</li> <li>able to be adopted incrementally (<code>tach init</code> and <code>tach add</code>)</li> <li>implemented with no runtime footprint</li> <li>interoperable with your existing tooling</li> </ul>"}]}